组合数学相关
------------

### 相关定理

#### 定理1

$\{1, 2, … n\}$的r组合$a_1, a_2,...,a_r$出现在所有r组合中的字典序位置编号：
$$index = C(n, r) - C(n - a_1, r) - C(n - a_2, r - 1) - … - C(n - a_r, 1)$$

#### 定理2

$$k * C(n, k) = n * C(n - 1, k - 1)$$
$$C(n, 0) + C(n, 2) + … = C(n, 1) + C(n, 3) + …$$
$$1 * C(n, 1) + 2 * C(n, 2) + … + n * C(n, n) = n * 2^{n - 1}$$

### 错位排列

$$D_n=n!\sum_{k=0}^{n}\frac{(-1)^k}{k!}$$

### Catalan数

凸多边形三角划分,n个节点组成二叉搜索树，n对括号正确匹配数目，1-n的出栈序列
$$C_n = \frac{C(2 * n, n)}{n + 1}$$
$$C_n = \frac{(4 * n - 2)}{n + 1} * C_n - 1$$ $$C_1 = 1$$

### Stirling数

#### 第一类Stirling数

s(p, k)将 p 个不同元素构成 k 个圆排列的数目。
$$s(p, k) = (p - 1) * s(p - 1, k) + s(p - 1, k - 1)$$

#### 第二类Stirling数

n个元素拆分k个集合的方案数记为S(n, k)。
$$S(p, k) = k * S(p - 1, k) + S(p - 1, k - 1)$$
$$S(p, 0) = 0, (p >= 1)$$ $$S(p, p) = 1, (p >= 0)$$
$$S(p, 1) = 1, (p >= 1)$$ $$S(p, 2) = 2^{p - 1} - 1, (p >= 2)$$
$$S(p, p - 1) = C(p, 2)$$

### Bell数

元素个数为n的集合的划分数目。 $$B_p = \sum_{i=0}^{p}S(p, i)$$
其中$S(p,i)$表示第二类Stirling数。
$$B_p = C(p - 1, 0) * B_0 + C(p - 1, 1) * B_1 + … + C(p - 1, p - 1) * B_{p - 1}$$

### 卢卡斯定理

若$p$是质数： $$C(n,m)\%p=C(n/p,m/p)*C(n\%p,m\%p)\%p$$
若$p$不是质数，令$p=p_1*p_2*...*p_n$，这里$p_i$是质数 $$\left\{
\begin{aligned}
C_n^m \equiv & a_1 \pmod {p_1} \\
C_n^m \equiv & a_2 \pmod {p_2} \\
\vdots \\
C_n^m \equiv & a_n \pmod {p_n}
\end{aligned}
\right.$$ 则分别求出$a_1,a_2,...,a_n$用中国剩余定理合并即可。

蔡勒公式（日期转星期）
----------------------

0-星期日，1-星期一，2-星期二，3-星期三，4-星期四，5-星期五，6-星期六

    int Change(int year, int month, int day){
        if(month == 1 || month == 2) month += 12, year --;
        int c = year/100, y = year%100, m = month, d = day;
        int W = c/4 - 2*c + y + y/4 + 26*(m+1)/10 + d - 1;
        if(W < 0) return (W + (-W/7 + 1)*7)%7;
        return W % 7;
    }

BSGS
----

处理最小化$X$使$Y^X \equiv Z\pmod P$

    typedef long long ll;
    map<ll, ll> hs;
    ll P, B, N, m, b_m, mul, now, ans1;
    bool pd;
    inline void clear(){pd = false, hs.clear();}
    inline ll fpow(ll a, ll p){
        ll ans = 1;
        for ( ;p ; p >>= 1, a = (ll)(a*a)%P) if (p&1) ans = ans * a % P;
        return ans;
    }
    int main(){
        while (~scanf("%lld%lld%lld",&P,&B,&N)){
            if (B % P ==0){printf("no solution\n"); continue;}
            clear();
            m = ceil(sqrt(P)), b_m = fpow(B,m);
            mul = 1, now = mul * N, hs[now] = 0;
            for (int i = 1; i <= m; i ++){
                mul = mul * B % P, now = mul * N % P;
                hs[now] = i;
            } mul = 1;
            for (int i = 1; i <= m; i ++) {
                mul = mul * b_m % P;
                if (hs[mul]){
                    pd = true, ans1 = i * m - hs[mul], printf("%lld\n", ans1);
                    break;
                }
            }if (!pd) printf("no solution\n");
        }
    }
